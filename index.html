<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Operational Transformation: Insert Characters</title>
<style>
  body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
  }
  .container {
    text-align: center;
  }
  #editor {
    margin: 20px;
    padding: 10px;
    border: 1px solid #ccc;
    width: 300px;
    display: flex;
    justify-content: space-between;
  }
  .char-box {
    border: 1px solid #ccc;
    width: 40px; /* Width should allow for one character */
    text-align: center;
  }
  #positions {
    display: flex;
    justify-content: space-between;
    width: 300px;
    margin-bottom: 20px;
  }
  .input-group {
    margin: 10px;
  }
</style>
</head>
<body>
<div class="container">
  <div id="editor">
    <div class="char-box">h</div>
    <div class="char-box">e</div>
    <div class="char-box">l</div>
    <div class="char-box">l</div>
    <div class="char-box">o</div>
  </div>
  <div id="positions">
    <span>0</span><span>1</span><span>2</span><span>3</span><span>4</span>
  </div>
  <div class="input-group">
    <input type="number" id="position1" placeholder="Position (i) 1" min="0" max="5" style="width: 140px;">
    <input type="text" id="character1" placeholder="Character 1" maxlength="1" style="width: 140px;">
  </div>
  <div class="input-group">
    <input type="number" id="position2" placeholder="Position (i) 2" min="0" max="5" style="width: 140px;">
    <input type="text" id="character2" placeholder="Character 2" maxlength="1" style="width: 140px;">
  </div>
  <button id="insertBtn">Insert Characters</button>
</div>

<script>
class Operation {
  constructor(opType, amount = null, text = null) {
    this.opType = opType;
    this.amount = amount;
    this.text = text;
  }
}

class OperationSeq {
  constructor() {
    this.operations = [];
  }

  add(operation) {
    this.operations.push(operation);
  }

  apply(content) {
    let result = '';
    let index = 0;
    for (const op of this.operations) {
      switch (op.opType) {
        case 'retain':
          result += content.substring(index, index + op.amount);
          index += op.amount;
          break;
        case 'insert':
          result += op.text;
          break;
        case 'delete':
          index += op.amount;
          break;
      }
    }
    result += content.substring(index);
    return result;
  }
}

const editor = document.getElementById('editor');

const insertBtn = document.getElementById('insertBtn');

insertBtn.addEventListener('click', function(event) {
  const position1 = parseInt(document.getElementById('position1').value);
  const character1 = document.getElementById('character1').value;
  const position2 = parseInt(document.getElementById('position2').value);
  const character2 = document.getElementById('character2').value;

  // Check that the user has entered valid positions and characters
  if ((isNaN(position1) || character1.length === 0) && (isNaN(position2) || character2.length === 0)) {
    alert('Please enter valid positions and characters.');
    return;
  }

  // Extract the current content from the .char-box elements
  const charBoxes = document.querySelectorAll('.char-box');
  let content = Array.from(charBoxes).map(box => box.textContent).join('');

  // Create the operation sequence
  let operationSeq = new OperationSeq();

  // Create an array to collect new positions after transformations
  let newPositions = [];

  if (!isNaN(position1) && character1.length > 0) {
    newPositions.push({pos: position1, char: character1});
  }

  if (!isNaN(position2) && character2.length > 0) {
    newPositions.push({pos: position2, char: character2});
  }

  // Sort new positions by pos value to retain order when inserting
  newPositions.sort((a, b) => a.pos - b.pos);

  // Insert characters according to new positions
  newPositions.forEach((item, index) => {
    const pos = item.pos + index; // adjust position for already inserted characters
    operationSeq.add(new Operation('retain', pos));
    operationSeq.add(new Operation('insert', null, item.char));
  });

  // Apply the transformation
  const transformedContent = operationSeq.apply(content);

  // Update the .char-box elements with the new content
  charBoxes.forEach((box, index) => {
    box.textContent = transformedContent[index] || '';
    console.log(transformedContent)
  });

  // Clear the input fields
  document.getElementById('position1').value = '';
  document.getElementById('character1').value = '';
  document.getElementById('position2').value = '';
  document.getElementById('character2').value = '';
});
